package org.vitrivr.cineast.core.features.abstracts;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

import org.vitrivr.cineast.core.config.Config;
import org.vitrivr.cineast.core.config.QueryConfig;
import org.vitrivr.cineast.core.data.ReadableFloatVector;
import org.vitrivr.cineast.core.data.StringDoublePair;
import org.vitrivr.cineast.core.db.DBSelector;
import org.vitrivr.cineast.core.db.DBSelectorSupplier;
import org.vitrivr.cineast.core.db.PersistencyWriter;
import org.vitrivr.cineast.core.db.PersistencyWriterSupplier;
import org.vitrivr.cineast.core.db.PersistentTuple;
import org.vitrivr.cineast.core.features.extractor.Extractor;
import org.vitrivr.cineast.core.features.retriever.Retriever;
import org.vitrivr.cineast.core.setup.EntityCreator;
import org.vitrivr.cineast.core.util.MathHelper;

import gnu.trove.map.TObjectDoubleMap;
import gnu.trove.map.hash.TObjectDoubleHashMap;

public abstract class AbstractFeatureModule implements Extractor, Retriever {
	
	protected PersistencyWriter<?> phandler;
	protected DBSelector selector;
	protected final float maxDist;
	protected final String tableName;

	protected AbstractFeatureModule(String tableName, float maxDist){
		this.tableName = tableName;
		this.maxDist = maxDist;
	}
	
	@Override
	public void init(PersistencyWriterSupplier phandlerSupply) {
		this.phandler = phandlerSupply.get();
		this.phandler.open(this.tableName);
	}
	
	@Override
	public void init(DBSelectorSupplier selectorSupply) {
		this.selector = selectorSupply.get();
		this.selector.open(this.tableName);
	}

	private float[] arrayCache = null; //avoiding the creation of new arrays on every call
	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected void persist(String shotId, ReadableFloatVector fv) {
		PersistentTuple tuple = this.phandler.generateTuple(shotId, arrayCache = fv.toArray(arrayCache));
		this.phandler.persist(tuple);
	}

	@Override
	public List<StringDoublePair> getSimilar(String shotId, QueryConfig qc) {
		List<float[]> list = this.selector.getFeatureVectors("id", shotId, "feature");
		if(list.isEmpty()){
			return new ArrayList<>(1);
		}
		if(list.size() == 1){
			return getSimilar(list.get(0), qc);
		}
		
		TObjectDoubleMap<String> maxPool = new TObjectDoubleHashMap<>();
		for(float[] vector : list){
			
			
			List<StringDoublePair> similar = getSimilar(vector, qc);
			
			for(StringDoublePair sdp : similar){
				if(maxPool.containsKey(sdp.key)){
					if(maxPool.get(sdp.key) < sdp.value){
						maxPool.put(sdp.key, sdp.value);
					}
				}else{
					maxPool.put(sdp.key, sdp.value);
				}
			}
			
		}
		
		ArrayList<StringDoublePair> _return = new ArrayList<>(maxPool.isEmpty() ? 1 : maxPool.size());
		for(String id : maxPool.keySet()){
			_return.add(new StringDoublePair(id, maxPool.get(id)));
		}
		
		return _return;
	}
	
	/**
	 * helper function to retrieve elements close to a vector which has to be generated by the feature module
	 */
	protected List<StringDoublePair> getSimilar(float[] vector, QueryConfig qc) {
		List<StringDoublePair> distances = this.selector.getNearestNeighbours(Config.getRetrieverConfig().getMaxResultsPerModule(), vector, "feature", qc);
		if(distances == null){
			return new ArrayList<>(1);
		}
		for(StringDoublePair sdp : distances){
			double dist = sdp.value;
			sdp.value = MathHelper.getScore(dist, maxDist);
		}
		return distances;
	}
	
	

	@Override
	public void finish() {
		if(this.phandler != null){
			this.phandler.close();
			this.phandler = null;
		}
		
		if(this.selector != null){
			this.selector.close();
			this.selector = null;
		}
	}

	@Override
	public void initalizePersistentLayer(Supplier<EntityCreator> supply) {
		supply.get().createFeatureEntity(this.tableName, true);
		
	}

}
